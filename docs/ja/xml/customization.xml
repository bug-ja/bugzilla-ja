<!-- <!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook V4.1//EN"> -->
<chapter id="customization">
  <title>Bugzilla のカスタマイズ</title>

  <section id="cust-skins">
    <title>カスタムスキン (外装)</title>
    
    <para>
      Bugzilla では複数の外装を利用することができます。これらには独自の CSS、
      そしておそらく独自の Bugzilla 用の画像が含まれるでしょう。
      新しい独自の外装を作成するには、二つの方法があります。
      <itemizedlist>
        <listitem>
          <para>
            単一の CSS ファイルを作り、
            <filename>skins/contrib</filename> ディレクトリに置く。
          </para>
        </listitem>
        <listitem>
          <para>
            <filename>skins/standard/</filename> ディレクトリにある全てと同じ名前の
            CSS ファイルを含むディレクトリを作成し、
            <filename>skins/contrib/</filename> に置く。
          </para>
        </listitem>
      </itemizedlist>
    </para>
      
    <para>
      ファイルを置くかディレクトリを作成したあと、ファイル権限を正しく設定するために
      checksetup.pl を必ず実行してください。
    </para>
    <para>
      新外装を導入すると、ユーザの一般的な設定の中に、
      オプションとして表示されるようになります。全ユーザに特定の外装を強制したい場合、
      既定の設定画面でそれを選択し、設定で変更を "有効にする" 
      のチェックを外してください。
    </para>
  </section>
  
  <section id="cust-templates">
    <title>テンプレートのカスタマイズ</title>
    
    <para>
      管理者は Perl ファイルを編集することや、将来の新バージョンへアップグレードする際に、
      マージでの衝突の悪夢に悩まされることなく、Bugzilla の表示を設定することが可能です。
    </para>
    
    <para>
      テンプレート化は Bugzilla のローカライズをも可能としました。
      Bugzilla の UI 言語をユーザのブラウザの設定から決定することも可能になりました。
      より詳細に関しては
      <xref linkend="template-http-accept"/> を参考にしてください。
    </para>
    
    <section id="template-directory">
      <title>テンプレートディレクトリ構造</title>
      <para>
        テンプレートディレクトリ構造は <filename>template</filename> 
        という名前の最上位ディレクトリの下に、インストールされている言語の
        ディレクトリが作成されています。一つ目のレベルのディレクトリは、
        テンプレートの言語が何かを示します。英語の Bugzilla テンプレートは、
        ディレクトリ名 <filename>en</filename> となり、全体としては
        <filename>template/en</filename> となります。この <filename>template/en</template>
        には、<filename>default</filename> ディレクトリがあり、Bugzilla 
        の標準的なテンプレートが入っています。
      </para>

      <warning>
        <para>
          <filename>data/templates</filename> も存在しますが、このディレクトリは
          Template Toolkit が既定のもしくはカスタムのディレクトリを、
          それぞれコンパイルしたものを保存する場所ですので、<emphasis>絶対に</emphasis> 
          このディレクトリのファイルは直接編集しないでください。
          もし編集したとしても次に Template Toolkit がコンパイルした時に、
          全てが失われます。
        </para>
      </warning>
    </section>

    <section id="template-method">
      <title>カスタマイズの方法の選択</title>
      <para>
        Bugzilla のテンプレートを編集する場合、最初にすべき決断は、
        実行するためにどうやるのか、ということです。二つの選択肢があり、
        主に編集内容がどういうものであるかや、アップグレードプランによります。
      </para> 

      <para>
        一つ目は、直接 <filename>template/en/default</filename>
        のディレクトリにあるテンプレートを編集するという方法です。
        CVS 経由で Bugzilla をアップデートするのであれば、
        この方法がもっとも望ましい方法でしょう。なぜなら、
        <command>cvs update</command> を実行した時に、あなたの変更も、
        更新されたバージョンに自動的にマージされるからです。
      </para>

      <note>
        <para>
          この方法をとった場合、CVS がアップデート中に衝突を検出すると、
          衝突したテンプレート (とおそらくサイトのほかの部分も) 
          は衝突を解消するまで動作しないでしょう。
        </para>
      </note>

      <para>
        二つ目の方法は、テンプレートを <filename>template/en/custom</filename>
        ディレクトリの中に同じディレクトリ構造でコピーし、それを変更するものです。
        このディレクトリ内のテンプレートは、自動的に同一の名前の 
        <filename>default</filename> ディレクトリにあるテンプレートを、
        上書きするものとして取り扱われます。
      </para>

      <note>
        <para>
          <filename>custom</filename> ディレクトリは最初から存在するものではなく、
          必要であればまず作成する必要があります。
        </para>
      </note>

      <para>
        二つ目の方法では、アップグレード時に上書きを行う場合に利用すべきで、
        そうでなければあなたの変更はなくなってしまいます。
        アップグレードに CVS を利用している場合でも、
        主要バージョン変更を行おうとしている場合にはこちらの方が適しています。
        このアップグレードにおいても、
        このディレクトリの中のファイルは影響を受けないことが保障されており、
        あなたのテンプレートを利用し続けるか、もしくは、
        新しいバージョンに手作業で変更を統合するかの選択が可能になります。
      </para>

      <para>
        この方法を利用する場合でも、あなたのサイトは、
        テンプレートに非互換の更新が行われた場合に動作しなくなる可能性があります。
        そういった変更は、Bugzilla の安定版を利用している場合は、
        リリースノートなどに記載されています。もし、開発版を利用している場合は、
        変更について前の安定版のリリースノートにある同様の部分に記載されるまでは、
        この更新については自分自身で十分に把握しておく必要があります。
      </para>

      <note>
        <para>
          どの方式を利用したとしても、
          <filename>template/en/default</filename> ディレクトリの中にある
          テンプレートを作成・更新した後や、<filename>custom</filename>
          ディレクトリ中のテンプレートを更新した際に、
          <command>./checksetup.pl</command> を実行する必要があります。 
        </para>
      </note>

      <warning>
        <para>
          <filename>custom</filename> ディレクトリに新しいテンプレートを作成したあと、
          <emphasis>必ず</emphasis> <command>./checksetup.pl</command>
          を実行してください。この時にエラーが発生していると、
          不完全なエラーメッセージが表示されることになります。
        </para>
      </warning>
    </section>
    
    <section id="template-edit">
      <title>テンプレートの編集方法</title>
      
      <note>
        <para>
          もし、テンプレートへの編集内容を Bugzilla そのものに反映させようとする場合、
          <ulink url="http://www.bugzilla.org/docs/developer.html">開発者ガイド
          </ulink> の関連する部分を読んでください。
        </para>
      </note>
      
      <para>
        Template Toolkit の言語そのものの仕様に関しては、このガイドの範囲ではありません。
        現在のテンプレートを参照することで、簡単な部分を把握することは可能でしょう。
        もしくは、
        <ulink url="http://www.template-toolkit.org">Template Toolkit ホームページ
        </ulink> にあるマニュアルを参照してください。
      </para>
      
      <para>
        特別の注意を払う必要がある部分は、テンプレートに渡されたデータに対する
        HTML フィルターを適切に行うところです。これは、
        データが特別な HTML 文字列を含む可能性がある場合、
        たとえば &lt; など、このデータは HTML に導入できないので、
        &amp;lt; といったエンティティー形式に変換する必要があります。
        このためには Template Toolkit の 'html' フィルターを利用できます。
        処理を忘れた場合、あなたのサイトが、
        クロスサイトスクリプティング攻撃の影響を受ける可能性があります。
      </para>

      <para>
        Bugzilla 自身もまたいくつかの Template Tookit 
        標準にないフィルターを定義しています。たとえば、'url_quote' 
        フィルターは URL として無効もしくは特別な意味を持つ文字、
        たとえば &amp; を %26 などのエンコードされた形式へを変換します。
        この処理は HTML 特殊文字を含む、ほとんどの文字 (ただし、
        文字や数字などの普通の文字を除く) を変換しますので、
        HTML フィルターに再度通す必要はありません。
      </para>
 
      <para>
        テンプレートの編集は <quote>簡単なカスタムフィールド</quote> 
        としても有用です。
        たとえば、ステータスホワイトボードが不要で、<quote>ビルド文字列</quote>
        のために自由入力フォームが必要な場合、
        テンプレートのフィールドラベルを編集することで実現できます。
        内部的には status_whiteboard を呼び出してはいますが、
        ユーザがそれを知ることはありません。
      </para>
      
    </section>
            
    
    <section id="template-formats">
      <title>テンプレート形式と型</title>
      
      <para>
        いくつかの CGI ではひとつ以上のテンプレートを利用しています。
        たとえば、<filename>buglist.cgi</filename> はそれ自身だけで RDF 
        や二つの形式の HTML (複雑なものと単純なもの) を出力できます。
        これを提供しているメカニズムは拡張して利用することが可能です。
      </para>

      <para>
        Bugzilla は異なる型の出力を行うことができ、
        前述のように複数の形式を提供できます。特定の型の要求は、
        <filename>&lt;cginame&gt;.cgi</filename> URL に、
        &amp;ctype=&lt;contenttype&gt; (rdf や html など) を付け加えることで行えます。
        特定の形式の要求は、URL に &amp;format=&lt;format&gt; 
        (simple や complex など) を付け加えることで行えます。
      </para>
      
      <para>
        CGI が複数の形式や型の出力をサポートしているかを判断するには、
        CGI を <quote>get_format</quote> で検索してください。存在していなくても、
        複数の形式や型のサポートは難しくはありません。config.cgi 
        などの既に行われている CGI を参照してください。
      </para>
      
      <para>
        これらをサポートしている CGI に新しい形式のテンプレートを付け加える場合、
        CGI が利用する既存のテンプレートを開き、(存在していれば)
        INTERFACE コメントを参照してください。
        このコメントはどのような変数がテンプレートに渡されるかを記述しています。
        もし記述がなければ、テンプレートやソースコードを読んで、
        取得したい情報がどのように渡されているかを見つける必要があります。
      </para>     
  
      <para>
        マークアップやテキストなどの必要な形式でテンプレートを記述してください。
      </para>
      
      <para>
        あなたのテンプレートでどのような型 (Content-Type) 
        を提供したいかを決定する必要があります。
        これらの型は、<filename>Bugzilla/Constants.pm</filename> 
        の <filename>contenttypes</filename> 定数で定義されています。
        もし、利用したい型がここに存在しなければ、追加してください。
        あなたが必要な型につけられている3文字もしくは4文字のタグを覚えてください。
        このタグがテンプレートのファイル名の一部となります。
      </para>

      <note>
        <para>
          型を追加・変更した後、変更を反映させるために、
          <filename>Bugzilla/Constants.pm</filename> を変更するのがいいでしょう。
          また、このファイルはアップグレード時にも、
          過去に型をカスタマイズしていた場合はそれらを反映させる必要があります。
        </para>
      </note>
      
      <para>
        テンプレートを
        <filename>&lt;stubname&gt;-&lt;formatname&gt;.&lt;contenttypetag&gt;.tmpl</filename>
        として保存してください。そして、テンプレートの試験のために CGI を
        <filename>&lt;cginame&gt;.cgi?format=&lt;formatname&gt;&amp;ctype=&lt;type&gt;</filename>
        として呼んでください。
      </para>
    </section>
    
    
    <section id="template-specific">
      <title>特別なテンプレート</title>
      
      <para>
        サイトでのカスタマイズの際に特別に興味を持つことになる、
        いくつかのテンプレートがあります。
      </para>
      
      <para>
        <command>index.html.tmpl</command>:
        Bugzilla のフロントページです。
      </para>      

      <para>
        <command>global/header.html.tmpl</command>:
        全ての Bugzilla のページで利用されるヘッダを定義しています。
        ヘッダは、ユーザの目を引き、おそらく編集したくなる、
        バナーの部分を含みます。しかしながら、このヘッダには
        HTML HEAD セクションも含まれており、
        これを参考にしてスタイルシートや META タグを追加することも可能です。
      </para>

      <para>
        <command>global/banner.html.tmpl</command>:
        <quote>バナー</quote> 本体を含んでおり、全ての Bugzilla 
        ページの先頭部分に表示されます。デフォルトのバナーは単純なものですので、
        サイトの特色のある表示に差し替えることとなるでしょう。
        いくつかのページに含まれる、Bugzilla バージョン番号は、
        どれを実行しているかを示すもので、ユーザにとって、
        どのドキュメントを読むべきかを知るのに利用できますので、残しておくべきです。
      </para>

      <para>
        <command>global/footer.html.tmpl</command>:
        全ての Bugzilla のページで利用されるフッタを定義しています。
        Bugzilla のサイトを特色のある表示に簡単に変更するために必要な、
        もう一つのファイルです。
      </para>

      <para>
        <command>global/variables.none.tmpl</command>:
        Bugzilla ではサイトごとに <quote>ブランド</quote> 付けをするために利用できる、
        用語のリストを定義しています。この方法により、<quote>bugs</quote> 
        のような用語を Bugzilla 全体で <quote>issues</quote> 
        に変換することが可能になります。
        <quote>Bugzilla</quote> の名前や他の単語を変更することができます。
      </para>

      <para>
        <command>list/table.html.tmpl</command>:
        このテンプレートは、Bugzilla によるバグリストの表示方法を定義しています。
        このテンプレートを利用することで、カラム毎の幅や、タイトル、
        各内容の最大表示長さ、長い文の折りたたみ方法を変更することが可能です。
        長いバグリストでは、Bugzilla は既定では 100 行ごとに '区切り'
        を挿入しますが、この動作もこのテンプレートで制御でき、
        この値も変更することができます。
       </para>

      <para>
        <command>bug/create/user-message.html.tmpl</command>:
        バグ報告ページの先頭部分に表示されるメッセージです。
        これを編集することで、ユーザにどのようにバグ報告を行うべきかを伝えられます。
      </para>

      <para>
        <command>bug/process/midair.html.tmpl</command>:
        同じバグに複数のユーザが似たような変更を加えようとした時に利用されるページです。
        二人目のユーザが変更した時、一人目がどのような変更を加えたかを表示し、
        その変更を上書きするか、もしくはバグに戻ってやり直すかを、
        ユーザが選択できるようになります。ページの既定のタイトルとヘッダは、
        "衝突が検出されました !" です。もし、航空業界や、
        その他のこのメッセージが攻撃的と思える環境 (注: 英語版の直訳は、
        "空中衝突検出 !" です) であれば (もちろんそういうことは十分にありえます)
        このメッセージをより環境にあった他のものに変更することになるでしょう。
      </para>

      <para>
        <command>bug/create/create.html.tmpl</command> と
        <command>bug/create/comment.txt.tmpl</command>:
        Bugzilla でのカスタムフィールドの恩恵を受けたくないと考えている場合でも、
        特別なフィールドを利用するのではなく、いくつかの重要な情報を、
        バグ報告に含むようにしたいと考えることがあるかもしれません。
        バグ登録システムは、ドロップダウンリスト、テキストボックスなど、
        自由に HTML ウイジェットを追加できるような拡張性のある設計になっており、
        それらに初期コメントとして値を入れることも可能です。
        隠しフィールド "format" は、
        テンプレートを正常に動作させるためにフォームの中に入れておく必要があります。
        この値はテンプレートのファイル名を接頭辞とします。
        たとえば、ファイルが <filename>create-cust.html.tmpl</filename>
        の場合、
        <programlisting>&lt;input type="hidden" name="format" value="cust"&gt;</programlisting>
        をフォームに含む必要があります。
      </para>

      <para>  
        このサンプルには mozilla.org の
        <ulink url="http://landfill.bugzilla.org/bugzilla-tip/enter_bug.cgi?product=WorldControl&amp;format=guided">
        ガイドつきバグ登録フォーム</ulink> があります。このコードは、
        Bugzilla 配布物の中にサンプルとして含まれています。
        <filename>create-guided.html.tmpl</filename> と
        <filename>comment-guided.html.tmpl</filename> です。
      </para>  

      <para>
        この機能を利用するには、<filename>enter_bug.cgi</filename>
        向けのカスタムテンプレートも必要です。ベースとして利用できる、
        既定のテンプレートは、
        <filename>custom/bug/create/create.html.tmpl</filename>
        となります。これを
        <filename>create-&lt;formatname&gt;.html.tmpl</filename> とし、
        ビルド番号や再現手順など、
        収集したい情報それぞれのためのウィジェットを追加してください。
      </para>

      <para>
        そして、テンプレートを
        <filename>custom/bug/create/comment.txt.tmpl</filename> の場所に、
        <filename>comment-&lt;formatname&gt;.txt.tmpl</filename> として置いてください。
        このテンプレートでは <filename>[% form.&lt;fieldname&gt; %]</filename>
        の形式で、作成したフォームフィールドの値を参照できるようになります。
        バグ報告の登録があると、バグ報告につけられる最初のコメントは、
        このテンプレートに従ってフォーマットされたものとなります。
      </para> 

      <para>
        たとえば、あなたの enter_bug テンプレートが
        <programlisting>&lt;input type="text" name="buildid" size="30"&gt;</programlisting>
        フィールドを持つ場合、comment.txt.tmpl に
        <programlisting>BuildID: [% form.buildid %]</programlisting>
        があれば、
        <programlisting>BuildID: 20020303</programlisting>
        などと最初のコメントに記録されます。
      </para>            
    </section>          


    <section id="template-http-accept">
      <title>Bugzilla をユーザの利用言語を考慮するよう設定する</title>

      <para>Bugzilla は Accept: HTTP ヘッダを参照します。
      他の言語のテンプレートも導入でき、Bugzilla はあなたが指定した順序に従い、
      最適な言語を選択します。さまざまな言語のテンプレートを <ulink 
      url="http://www.bugzilla.org/download.html#localizations"/> から入手できます。
      新しい言語の登録方法に関しても上記ページにあります。
      </para>
    </section>
      
  </section>

  <section id="cust-hooks">
    <title>Bugzilla 拡張メカニズム</title>
    
    <warning>
      <para>
        注: 以下の内容は整合性がなく混乱の元かもしれません。
        この内容は Bugzilla 4.0 までに変更される可能性があります。
      </para>
    </warning>
       
    <para>
      Extensions are a way for extensions to Bugzilla to insert code
      into the standard Bugzilla templates and source files
      without modifying these files themselves.  The extension mechanism 
      defines a consistent API for extending the standard templates and source files 
      in a way that cleanly separates standard code from extension code.  
      Hooks reduce merge conflicts and make it easier to write extensions that work 
      across multiple versions of Bugzilla, making upgrading a Bugzilla installation 
      with installed extensions easier. Furthermore, they make it easy to install 
      and remove extensions as each extension is nothing more than a 
      simple directory structure. 
    </para>
    
    <para>
      There are two main types of hooks: code hooks and template hooks. Code 
      hooks allow extensions to invoke code at specific points in various 
      source files, while template hooks allow extensions to add elements to 
      the Bugzilla user interface. 
    </para>

    <para>
      A hook is just a named place in a standard source or template file
      where extension source code or template files for that hook get processed. 
      Each extension has a corresponding directory in the Bugzilla directory 
      tree (<filename>BUGZILLA_ROOT/extensions/extension_name</filename>).  Hooking 
      an extension source file or template to a hook is as simple as putting 
      the extension file into extension's template or code directory. 
      When Bugzilla processes the source file or template and reaches the hook, 
      it will process all extension files in the hook's directory. 
      The hooks themselves can be added into any source file or standard template 
      upon request by extension authors.
    </para>
    
    <para>
      To use hooks to extend Bugzilla, first make sure there is
      a hook at the appropriate place within the source file or template you 
      want to extend. The exact appearance of a hook depends on if the hook 
      is a code hook or a template hook. 
    </para>
    
    <para>
      Code hooks appear in Bugzilla source files as a single method call 
      in the format <literal role="code">Bugzilla::Hook->process("<varname>name</varname>");</literal>.
      For instance, <filename>enter_bug.cgi</filename> may invoke the hook 
      "<varname>enter_bug-entrydefaultvars</varname>". Thus, a source file at 
      <filename>BUGZILLA_ROOT/extensions/EXTENSION_NAME/code/enter_bug-entrydefaultvars.pl</filename>
      will be automatically invoked when the code hook is reached. 
    </para>
   
    <para>  
      Template hooks appear in the standard Bugzilla templates as a 
      single directive in the format
      <literal role="code">[% Hook.process("<varname>name</varname>") %]</literal>,
      where <varname>name</varname> is the unique name of the hook.
    </para>

    <para>
      If you aren't sure what you want to extend or just want to browse the 
      available hooks, either use your favorite multi-file search
      tool (e.g. <command>grep</command>) to search the standard templates
      for occurrences of <methodname>Hook.process</methodname> or the source 
      files for occurrences of <methodname>Bugzilla::Hook::process</methodname>.
    </para>

    <para>
      If there is no hook at the appropriate place within the Bugzilla 
      source file or template you want to extend,
      <ulink url="http://bugzilla.mozilla.org/enter_bug.cgi?product=Bugzilla&amp;component=User%20Interface">file
      a bug requesting one</ulink>, specifying:
    </para>

    <simplelist>
      <member>the source or template file for which you are 
          requesting a hook;</member>
      <member>
        where in the file you would like the hook to be placed
        (line number/position for latest version of the file in CVS
        or description of location);
      </member>
      <member>the purpose of the hook;</member>
      <member>a link to information about your extension, if any.</member>
    </simplelist>

    <para>
      The Bugzilla reviewers will promptly review each hook request,
      name the hook, add it to the template or source file, and check 
      the new version of the template into CVS.
    </para>

    <para>
      You may optionally attach a patch to the bug which implements the hook
      and check it in yourself after receiving approval from a Bugzilla
      reviewer.  The developers may suggest changes to the location of the
      hook based on their analysis of your needs or so the hook can satisfy
      the needs of multiple extensions, but the process of getting hooks
      approved and checked in is not as stringent as the process for general
      changes to Bugzilla, and any extension, whether released or still in
      development, can have hooks added to meet their needs.
    </para>

    <para>
      After making sure the hook you need exists (or getting it added if not),
      add your extension to the directory within the Bugzilla
      extensions tree corresponding to the hook. 
    </para>
    
    <para>
      That's it!  Now, when the source file or template containing the hook
      is processed, your extension file will be processed at the point 
      where the hook appears.
    </para>

    <para>
      For example, let's say you have an extension named Projman that adds
      project management capabilities to Bugzilla.  Projman has an
      administration interface <filename>edit-projects.cgi</filename>, 
      and you want to add a link to it into the navigation bar at the bottom
      of every Bugzilla page for those users who are authorized
      to administer projects.
    </para>

    <para>
      The navigation bar is generated by the template file
      <filename>useful-links.html.tmpl</filename>, which is located in
      the <filename>global/</filename> subdirectory on the standard Bugzilla 
      template path
      <filename>BUGZILLA_ROOT/template/en/default/</filename>.
      Looking in <filename>useful-links.html.tmpl</filename>, you find
      the following hook at the end of the list of standard Bugzilla
      administration links:
    </para>

    <programlisting><![CDATA[...
    [% ', <a href="editkeywords.cgi">keywords</a>' 
       IF user.in_group('editkeywords') %]
    [% Hook.process("edit") %]
...]]></programlisting>

    <para>
      The corresponding extension file for this hook is
      <filename>BUGZILLA_ROOT/extensions/projman/template/en/global/useful-links-edit.html.tmpl</filename>.
      You then create that template file and add the following constant:
    </para>

    <programlisting><![CDATA[...[% ', <a href="edit-projects.cgi">projects</a>' IF user.in_group('projman_admins') %]]]></programlisting>

    <para>
      Voila!  The link now appears after the other administration links in the
      navigation bar for users in the <literal>projman_admins</literal> group.
    </para>
    
    <para>
      Now, let us say your extension adds a custom "project_manager" field 
      to enter_bug.cgi. You want to modify the CGI script to set the default 
      project manager to be productname@company.com. Looking at 
      <filename>enter_bug.cgi</filename>, you see the enter_bug-entrydefaultvars 
      hook near the bottom of the file before the default form values are set. 
      The corresponding extension source file for this hook is located at 
      <filename>BUGZILLA_ROOT/extensions/projman/code/enter_bug-entrydefaultvars.pl</filename>.
      You then create that file and add the following:
    </para>
    
    <programlisting>$default{'project_manager'} = $product.'@company.com';</programlisting>
    
    <para>
      This code will be invoked whenever enter_bug.cgi is executed. 
      Assuming that the rest of the customization was completed (e.g. the 
      custom field was added to the enter_bug template and the required hooks 
      were used in process_bug.cgi), the new field will now have this 
      default value. 
    </para>
      
    <para>
      Notes:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          If your extension includes entirely new templates in addition to
          extensions of standard templates, it should store those new
          templates in its
          <filename>BUGZILLA_ROOT/extensions/template/en/</filename> 
          directory. Extension template directories, like the 
          <filename>default/</filename> and <filename>custom/</filename>
          directories, are part of the template search path, so putting templates
          there enables them to be found by the template processor.
        </para>

        <para>
          The template processor looks for templates first in the
          <filename>custom/</filename> directory (i.e. templates added by the 
          specific installation), then in the <filename>extensions/</filename>
          directory (i.e. templates added by extensions), and finally in the 
          <filename>default/</filename> directory (i.e. the standard Bugzilla 
          templates). Thus, installation-specific templates override both 
          default and extension templates.
        </para>
      </listitem>

      <listitem>
        <para>
          If you are looking to customize Bugzilla, you can also take advantage 
          of template hooks. To do so, create a directory in
          <filename>BUGZILLA_ROOT/template/en/custom/hook/</filename>
          that corresponds to the hook you wish to use, then place your 
          customization templates into those directories. For example, 
          if you wanted to use the hook "end" in 
          <filename>global/useful-links.html.tmpl</filename>, you would 
          create the directory <filename>BUGZILLA_ROOT/template/en/custom/hook/
          global/useful-links.html.tmpl/end/</filename> and add your customization 
          template to this directory. 
        </para>

        <para>
          Obviously this method of customizing Bugzilla only lets you add code
          to the standard source files and templates; you cannot change the 
          existing code. Nevertheless, for those customizations that only add 
          code, this method can reduce conflicts when merging changes, 
          making upgrading your customized Bugzilla installation easier.
        </para>
      </listitem>
    </itemizedlist>    
  </section>

  <section id="cust-change-permissions">
    <title>Customizing Who Can Change What</title>
    
    <warning>
      <para>
        This feature should be considered experimental; the Bugzilla code you
        will be changing is not stable, and could change or move between 
        versions. Be aware that if you make modifications as outlined here, 
        you may have
        to re-make them or port them if Bugzilla changes internally between
        versions, and you upgrade.
      </para>
    </warning>
      
    <para>
      Companies often have rules about which employees, or classes of employees,
      are allowed to change certain things in the bug system. For example, 
      only the bug's designated QA Contact may be allowed to VERIFY the bug.
      Bugzilla has been
      designed to make it easy for you to write your own custom rules to define
      who is allowed to make what sorts of value transition.
    </para>

    <para>
     By default, assignees, QA owners and users
     with <emphasis>editbugs</emphasis> privileges can edit all fields of bugs, 
     except group restrictions (unless they are members of the groups they 
     are trying to change). Bug reporters also have the ability to edit some 
     fields, but in a more restrictive manner. Other users, without 
     <emphasis>editbugs</emphasis> privileges, can not edit 
     bugs, except to comment and add themselves to the CC list.
    </para> 
    
    <para>
      For maximum flexibility, customizing this means editing Bugzilla's Perl 
      code. This gives the administrator complete control over exactly who is
      allowed to do what. The relevant method is called
      <filename>check_can_change_field()</filename>,
      and is found in <filename>Bug.pm</filename> in your
      Bugzilla/ directory. If you open that file and search for
      <quote>sub check_can_change_field</quote>, you'll find it.
    </para>
    
    <para>
      This function has been carefully commented to allow you to see exactly
      how it works, and give you an idea of how to make changes to it.
      Certain marked sections should not be changed - these are
      the <quote>plumbing</quote> which makes the rest of the function work.
      In between those sections, you'll find snippets of code like:
      <programlisting>    # Allow the assignee to change anything.
    if ($ownerid eq $whoid) {
        return 1;
    }</programlisting>
      It's fairly obvious what this piece of code does.
    </para>      
      
    <para>
      So, how does one go about changing this function? Well, simple changes
      can be made just by removing pieces - for example, if you wanted to 
      prevent any user adding a comment to a bug, just remove the lines marked
      <quote>Allow anyone to change comments.</quote> If you don't want the
      Reporter to have any special rights on bugs they have filed, just
      remove the entire section that deals with the Reporter.
    </para>
    
    <para>
      More complex customizations are not much harder. Basically, you add
      a check in the right place in the function, i.e. after all the variables
      you are using have been set up. So, don't look at $ownerid before 
      $ownerid has been obtained from the database. You can either add a
      positive check, which returns 1 (allow) if certain conditions are true,
      or a negative check, which returns 0 (deny.) E.g.:
      <programlisting>    if ($field eq "qacontact") {
        if (Bugzilla->user->in_group("quality_assurance")) {
            return 1;
        } 
        else {
            return 0;
        }
    }</programlisting>
      This says that only users in the group "quality_assurance" can change
      the QA Contact field of a bug.
    </para>

    <para>
      Getting more weird:
      <programlisting><![CDATA[    if (($field eq "priority") &&
        (Bugzilla->user->email =~ /.*\@example\.com$/))
    {
        if ($oldvalue eq "P1") {
            return 1;
        } 
        else {
            return 0;
        }
    }]]></programlisting>
      This says that if the user is trying to change the priority field,
      and their email address is @example.com, they can only do so if the
      old value of the field was "P1". Not very useful, but illustrative.
    </para>

    <warning>
      <para>
        If you are modifying <filename>process_bug.cgi</filename> in any
        way, do not change the code that is bounded by DO_NOT_CHANGE blocks.
        Doing so could compromise security, or cause your installation to
        stop working entirely.
      </para>
    </warning>
    
    <para>
      For a list of possible field names, look at the bugs table in the 
      database. If you need help writing custom rules for your organization,
      ask in the newsgroup.
    </para>    
  </section>   

  <!-- Integrating Bugzilla with Third-Party Tools -->
  &integration;

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-always-quote-attributes:t
sgml-auto-insert-required-elements:t
sgml-balanced-tag-edit:t
sgml-exposed-tags:nil
sgml-general-insert-case:lower
sgml-indent-data:t
sgml-indent-step:2
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-minimize-attributes:nil
sgml-namecase-general:t
sgml-omittag:t
sgml-parent-document:("Bugzilla-Guide.xml" "book" "chapter")
sgml-shorttag:t
sgml-tag-region-if-active:t
End:
-->

